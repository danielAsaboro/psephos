/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  type ParsedCastVoteInstruction,
  type ParsedCreateProposalInstruction,
  type ParsedFinalizeProposalInstruction,
  type ParsedRevealVoteInstruction,
} from "../instructions";

export const PSEPHOS_PROGRAM_ADDRESS =
  "DkCDEbhWqNUFto7AZQxvu2H5eiKV3whWEZDcPMqQeB4u" as Address<"DkCDEbhWqNUFto7AZQxvu2H5eiKV3whWEZDcPMqQeB4u">;

export enum PsephosAccount {
  Proposal,
  ProposalResults,
  VoteRecord,
}

export function identifyPsephosAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): PsephosAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([26, 94, 189, 187, 116, 136, 53, 33]),
      ),
      0,
    )
  ) {
    return PsephosAccount.Proposal;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([209, 94, 70, 52, 201, 209, 173, 240]),
      ),
      0,
    )
  ) {
    return PsephosAccount.ProposalResults;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([112, 9, 123, 165, 234, 9, 157, 167]),
      ),
      0,
    )
  ) {
    return PsephosAccount.VoteRecord;
  }
  throw new Error(
    "The provided account could not be identified as a psephos account.",
  );
}

export enum PsephosInstruction {
  CastVote,
  CreateProposal,
  FinalizeProposal,
  RevealVote,
}

export function identifyPsephosInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): PsephosInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([20, 212, 15, 189, 69, 180, 69, 151]),
      ),
      0,
    )
  ) {
    return PsephosInstruction.CastVote;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([132, 116, 68, 174, 216, 160, 198, 22]),
      ),
      0,
    )
  ) {
    return PsephosInstruction.CreateProposal;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([23, 68, 51, 167, 109, 173, 187, 164]),
      ),
      0,
    )
  ) {
    return PsephosInstruction.FinalizeProposal;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([100, 157, 139, 17, 186, 75, 185, 149]),
      ),
      0,
    )
  ) {
    return PsephosInstruction.RevealVote;
  }
  throw new Error(
    "The provided instruction could not be identified as a psephos instruction.",
  );
}

export type ParsedPsephosInstruction<
  TProgram extends string = "DkCDEbhWqNUFto7AZQxvu2H5eiKV3whWEZDcPMqQeB4u",
> =
  | ({
      instructionType: PsephosInstruction.CastVote;
    } & ParsedCastVoteInstruction<TProgram>)
  | ({
      instructionType: PsephosInstruction.CreateProposal;
    } & ParsedCreateProposalInstruction<TProgram>)
  | ({
      instructionType: PsephosInstruction.FinalizeProposal;
    } & ParsedFinalizeProposalInstruction<TProgram>)
  | ({
      instructionType: PsephosInstruction.RevealVote;
    } & ParsedRevealVoteInstruction<TProgram>);
